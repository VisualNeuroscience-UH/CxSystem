<?xml version="1.0" encoding="ISO-8859-1"?><xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
xmlns:SMLLOWNL="http://www.shef.ac.uk/SpineMLLowLevelNetworkLayer" 
xmlns:SMLNL="http://www.shef.ac.uk/SpineMLNetworkLayer" 
xmlns:SMLCL="http://www.shef.ac.uk/SpineMLComponentLayer" 
xmlns:SMLEX="http://www.shef.ac.uk/SpineMLExperimentLayer" 
xmlns:fn="http://www.w3.org/2005/xpath-functions">
<xsl:output method="text" version="1.0" encoding="UTF-8" indent="yes"/>

<xsl:param name="model_dir"/>
<xsl:param name="log_dir"/>

<xsl:template match="/">

<xsl:variable name="experiment_file" select="/"/>

<!-- since we start in the experiment file we need to use for-each to get to the model file -->
<xsl:variable name="model_xml" select="//SMLEX:Model/@network_layer_url"/>
<xsl:for-each select="document($model_xml)"> <!-- GET INTO NETWORK FILE -->

<xsl:variable name="model_file" select="/"/>

//--------------------------------------------------------------------------
/*! This function is the entry point for running the simulation in GeNN
	Autogenerated using XSLT script - Alex Cope 2013

*/
//--------------------------------------------------------------------------

#include &lt;cuda_runtime.h&gt;
//#include &lt;helper_cuda.h&gt;

#include "../../lib/include/hr_time.h"
CStopWatch timer;
#include "../../lib/include/hr_time.cpp"

#include "../../lib/include/numlib/simpleBit.h"

#include "model.cc"
#include "<xsl:value-of select="translate(/SMLLOWNL:SpineML/@name,' ','_')"/>_CODE/runner.cc"
#include &lt;algorithm&gt;

#define CPU 0
#define GPU 1

// GLOBALS
float t = 0.0f;

#ifndef __RNG_FUNCS_
#define __RNG_FUNCS_

#include "rng.h"

// Some data for the random number generator.
RngData rngData;

float uniformRand(float min, float max) {
	return _randomUniform(&amp;rngData)*(max-min)+min;
}
float normalRand(float mean, float std) {
	return _randomNormal(&amp;rngData)*std-mean;
}
float poissonRand() {
	return _randomPoisson(&amp;rngData);
}

#endif

struct conn {
	unsigned int src;
	unsigned int dst;
};
	
struct conn_with_delay : conn {
	float delay;
};

// sorting function for connections

bool sortConn (conn a,conn b) 
{ 
	if (a.src &lt; b.src) return true;
	if (a.src == b.src &amp;&amp; a.dst &lt; b.dst) return true;
	return false;
}

struct prop {
	unsigned int ind;
	float val;
};

// sorting function for properties

bool sortProp (prop a,prop b) 
{ 
	if (a.ind &lt; b.ind) return true;
	return false;
}

int main(int argc, char *argv[])
{

	zigset(&amp;rngData,123);

// safety first:
if (sizeof(conn) != 8) {
	cerr &lt;&lt; "Error: Expected a structure of 2 unsigned ints to be 8 bytes - this is not the case\n\n";
	exit(-1);
}
if (sizeof(conn_with_delay) != 12) {
	cerr &lt;&lt; "Error: Expected a structure of 2 unsigned ints and a float to be 12 bytes - this is not the case\n\n";
	exit(-1);
}

printf("Size checks successful\n");

// for now....
	int which = GPU;

// DEFINES
  NNmodel model;

// SOME SETUP
  modelDefinition(model);
  allocateMem();
  initialize();

  //-----------------------------------------------------------------
  
// ALLOCATE THE SPARSE CONNECTIVITY
<xsl:for-each select="//SMLLOWNL:Synapse">
	<xsl:variable name="src_size" select="../../SMLLOWNL:Neuron/@size"/>
	<xsl:variable name="dst_pop_name" select="../@dst_population"/>
	<xsl:variable name="dst_size" select="//SMLLOWNL:Neuron[@name=$dst_pop_name]/@size"/>
	<xsl:variable name="varName"><xsl:value-of select="concat('Synapse',position())"/>_<xsl:value-of select="translate(../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../@dst_population,' -','SH')"/></xsl:variable>
	<!-- XSLT to calculate the name of the memory array for the synapse is long - so pre-calculate  -->
	<!-- TEST FOR SPARSENESS: -->
	<xsl:variable name="maxConnSize" select="number(//SMLLOWNL:Neuron[@name=$dst_pop_name]/@size)*number(../../SMLLOWNL:Neuron/@size)"/>
	<xsl:if test="not(number(SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count(.//SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number(.//@num_connections) div number($maxConnSize))>number(0.1)) ">
	<xsl:choose>
		<xsl:when test="SMLNL:ConnectionList">
			<!-- fill in the array from the file, or XSLT -->
			<xsl:if test="SMLNL:ConnectionList/SMLNL:BinaryFile">
				<!-- binary file time - let's go! -->					
<!---->			<!---->	{unsigned int connN = <xsl:value-of select="SMLNL:ConnectionList/SMLNL:BinaryFile/@num_connections"/>;				
<!---->			<!----> allocate<xsl:value-of select="concat('Synapse',position())"/>_<xsl:value-of select="translate(../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../@dst_population,' -','SH')"/>(connN);}
			</xsl:if>
			<xsl:if test="count(SMLNL:ConnectionList/SMLNL:Connection) > 0">
				<xsl:variable name="curr_prop" select="."/>
				<!-- non-binary list - expand out -->
				<xsl:if test="count(SMLNL:ConnectionList/SMLNL:Connection) > 50">
					<xsl:message terminate="no">
Warning: Large connection list detected, code generation will be inefficient - consider using the BinaryFile tag
					</xsl:message>
				</xsl:if>
<!---->			<!---->	{unsigned int connN = <xsl:value-of select="count(SMLNL:ConnectionList/SMLNL:Connection)"/>;				
<!---->			<!----> allocate<xsl:value-of select="concat('Synapse',position())"/>_<xsl:value-of select="translate(../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../@dst_population,' -','SH')"/>(connN);}	
			</xsl:if>	
		</xsl:when>
		<xsl:when test="SMLNL:FixedProbabilityConnection">
			<!-- We'll generate the real connectivity here - and then pick it up later after we've allocated the sparse array -->
			<!-- First we need a container -->
<!---->		<!---->	vector &lt; conn &gt; tempConns<xsl:value-of select="$varName"/>;
			<!-- Loop and generate NO SEED CURRENTLY WHICH IS AN ISSUE -->
			for (int s = 0; s &lt; <xsl:value-of select="$src_size"/>; ++s) {
				for (int d = 0; d &lt; <xsl:value-of select="$dst_size"/>; ++d) {
					if (UNI(&amp;rngData) &lt; <xsl:value-of select="SMLNL:FixedProbabilityConnection/@probability"/>) {
						conn newConn;
						newConn.src = s;
						newConn.dst = d;
						tempConns<xsl:value-of select="$varName"/>.push_back(newConn);
					}
				}			
			}
<!---->		<!----> {unsigned int connN = tempConns<xsl:value-of select="$varName"/>.size();				
<!---->		<!----> allocate<xsl:value-of select="concat('Synapse',position())"/>_<xsl:value-of select="translate(../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../@dst_population,' -','SH')"/>(connN);	}
		</xsl:when>
		<xsl:when test="SMLNL:AllToAllConnection">
		</xsl:when>
		<xsl:when test="SMLNL:OneToOneConnection">
			<!-- FOR NOW WE USE A SPARSE ARRAY -->
<!---->		<!----> {unsigned int connN = <xsl:value-of select="../../SMLLOWNL:Neuron/@size"/>;				
<!---->		<!----> allocate<xsl:value-of select="concat('Synapse',position())"/>_<xsl:value-of select="translate(../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../@dst_population,' -','SH')"/>(connN);}		
		</xsl:when>		
		<xsl:otherwise>
			<xsl:message terminate="yes">
Error: Unrecognised connection type
			</xsl:message>
		</xsl:otherwise>
	</xsl:choose>
	</xsl:if>
</xsl:for-each>  
  
// GENERATE CONNECTIVITY
<xsl:for-each select="//SMLLOWNL:Synapse">
	<xsl:variable name="src_size" select="../../SMLLOWNL:Neuron/@size"/>
	<xsl:variable name="dst_pop_name" select="../@dst_population"/>
	<xsl:variable name="dst_size" select="//SMLLOWNL:Neuron[@name=$dst_pop_name]/@size"/>
	<xsl:variable name="varName"><xsl:value-of select="concat('Synapse',position())"/>_<xsl:value-of select="translate(../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../@dst_population,' -','SH')"/></xsl:variable>
	<xsl:variable name="maxConnSize" select="number(//SMLLOWNL:Neuron[@name=$dst_pop_name]/@size)*number(../../SMLLOWNL:Neuron/@size)"/>
	<!-- XSLT to calculate the name of the memory array for the synapse is long - so pre-calculate  -->
	<xsl:choose>
		<xsl:when test="SMLNL:OneToOneConnection">
			<!-- To be handled natively, but for now: -->
			<!-- sanity check -->
			<xsl:if test="not($src_size=$dst_size)">
				<xsl:message terminate="yes">
Error: One to one connection has different source and destination population sizes
				</xsl:message>
			</xsl:if>
			<!-- WRITE A SPARSE 1-2-1 ARRAY -->
<!---->	for (int i = 0; i &lt; <xsl:value-of select="../../SMLLOWNL:Neuron/@size"/>; ++i) {
<!---->		C<xsl:value-of select="$varName"/>.ind[i] = i;		
<!---->		C<xsl:value-of select="$varName"/>.indInG[i] = i;		
<!---->	}
	C<xsl:value-of select="$varName"/>.indInG[<xsl:value-of select="../../SMLLOWNL:Neuron/@size"/>] =  <xsl:value-of select="../../SMLLOWNL:Neuron/@size"/>;
		</xsl:when>
		<xsl:when test="SMLNL:AllToAllConnection">
			<xsl:for-each select="SMLLOWNL:WeightUpdate/SMLNL:Property">
				<xsl:variable name="propName" select="@name"/>
				<xsl:variable name="synapse_array_name">
					<xsl:if test="document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeGradedSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeLearningSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeSynapse'">
						<xsl:value-of select="concat('gp',$varName)"/>
					</xsl:if>
					<xsl:if test="not(document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeGradedSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeLearningSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeSynapse')">
						<xsl:value-of select="concat(@name ,'_WU',$varName)"/>
					</xsl:if>
				</xsl:variable>
				<xsl:if test="SMLNL:UniformDistribution">
<!---->				<!---->	// seed the RNG	
<!---->				<!---->	rngData.seed = <xsl:value-of select=".//@seed"/>;
<!---->				<!-- loop connections and fill in memory array -->
<!---->				<!---->	for (int i = 0; i &lt; <xsl:value-of select="concat($src_size,'*',$dst_size)"/>; ++i) {
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <!---->
					<!---->uniformRand(<xsl:value-of select="SMLNL:UniformDistribution/@minimum"/>,<xsl:value-of select="SMLNL:UniformDistribution/@maximum"/>);			
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:NormalDistribution">
<!---->				<!---->	// seed the RNG	
<!---->				<!---->	rngData.seed = <xsl:value-of select=".//@seed"/>;
<!---->				<!-- loop connections and fill in memory array -->
<!---->				<!---->	for (int i = 0; i &lt; <xsl:value-of select="concat($src_size,'*',$dst_size)"/>; ++i) {
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <!---->
					<!---->normalRand(<xsl:value-of select="SMLNL:NormalDistribution/@mean"/>,<xsl:value-of select="SMLNL:NormalDistribution/@variance"/>);			
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:PoissonDistribution">
<!---->				<!---->	// seed the RNG	
<!---->				<!---->	rngData.seed = <xsl:value-of select=".//@seed"/>;
<!---->				<!-- loop connections and fill in memory array -->
<!---->				<!---->	for (int i = 0; i &lt; <xsl:value-of select="concat($src_size,'*',$dst_size)"/>; ++i) {
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = poissonRand();			
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:FixedValue and document(../@url)//SMLCL:StateVariable[@name=$propName]">
					<!-- loop connections and fill in memory array -->
					<!---->	for (int i = 0; i &lt; <xsl:value-of select="concat($src_size,'*',$dst_size)"/>; ++i) {		
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <xsl:value-of select="SMLNL:FixedValue/@value"/>;
<!---->				<!---->	}
				</xsl:if>
			</xsl:for-each>
		</xsl:when>
		<xsl:when test="SMLNL:ConnectionList | SMLNL:FixedProbabilityConnection">
			<!-- CONNECTIVITY -->
			<!-- Extract into local memory -->
			<xsl:if test="count(SMLNL:ConnectionList/SMLNL:Connection)>0">
				<xsl:if test="count(SMLNL:ConnectionList//@delay)>0">
					<xsl:message terminate="no">
Error: Explicit delays used - these are not yet supported so won't affect anything
					</xsl:message>
				</xsl:if>
<!---->			<!---->	vector &lt; conn &gt; tempConns<xsl:value-of select="$varName"/>;
<!---->			<!---->	{conn newConn; 
<!---->			<!---->	// mind bogglingly silly way of setting up the vector!
<!---->			<xsl:for-each select="SMLNL:ConnectionList/SMLNL:Connection">
<!---->			<!---->	newConn.src = <xsl:value-of select="@src_neuron"/>; newConn.dst = <xsl:value-of select="@dst_neuron"/>;
<!---->			<!---->	tempConns<xsl:value-of select="$varName"/>.push_back(newConn);
<!---->			</xsl:for-each>
<!---->			<!---->	}
			</xsl:if>
			<xsl:if test="SMLNL:ConnectionList/SMLNL:BinaryFile">
				<!-- binary file time - let's go! -->
				<xsl:if test="SMLNL:ConnectionList/SMLNL:BinaryFile/@explicit_delay_flag='0'">
				<!---->	vector &lt; conn &gt; tempConns<xsl:value-of select="$varName"/>;
<!---->			</xsl:if>
				<xsl:if test="SMLNL:ConnectionList/SMLNL:BinaryFile/@explicit_delay_flag='1'">
				<!---->	vector &lt; conn_with_delay &gt; tempConns<xsl:value-of select="$varName"/>;
<!---->			</xsl:if>
				<!---->	tempConns<xsl:value-of select="$varName"/>.resize(<xsl:value-of select="SMLNL:ConnectionList/SMLNL:BinaryFile/@num_connections"/>);
<!---->			<!---->	{ // scope to allow us to reuse the file name locally
<!---->			<!---->	FILE * conn_file;
<!---->			<!---->	conn_file = fopen("<xsl:value-of select="SMLNL:ConnectionList/SMLNL:BinaryFile/@file_name"/>","rb");
<!---->			<!---->	if (!conn_file) {
<!---->			<!---->		cerr &lt;&lt; "Error opening binary connection file\n\n"; exit(-1);}
<!---->			<xsl:if test="SMLNL:ConnectionList/SMLNL:BinaryFile/@explicit_delay_flag='0'">
				<!---->	fread(&amp;tempConns<xsl:value-of select="$varName"/>[0], sizeof(conn), <xsl:value-of select="SMLNL:ConnectionList/SMLNL:BinaryFile/@num_connections"/>,conn_file);
<!---->			</xsl:if>
				<xsl:if test="SMLNL:ConnectionList/SMLNL:BinaryFile/@explicit_delay_flag='1'">
				<!---->	fread(&amp;tempConns<xsl:value-of select="$varName"/>[0], sizeof(conn_with_delay), <xsl:value-of select="SMLNL:ConnectionList/SMLNL:BinaryFile/@num_connections"/>,conn_file);
<!---->			</xsl:if>
<!---->			<!---->	}
			</xsl:if>
			<!-- DENSE CONNECTIVITY -->
			<xsl:if test="number(SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count(.//SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number(.//@num_connections) div number($maxConnSize))>number(0.1) ">
				<!---->	memset(gp<xsl:value-of select="$varName"/>,<!---->
				<!---->0,<!---->
				<xsl:value-of select="concat('sizeof(float)*',$src_size,'*',$dst_size)"/>);
<!---->			<!---->	for (int ind = 0; ind &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++ind) {
<!---->			<!----><xsl:text>		</xsl:text>gp<xsl:value-of select="$varName"/>[connections[i].dst*<xsl:value-of select="$src_size"/>+connections[i].src] = 1.0;
<!---->			<!---->	}			
			</xsl:if>
			<!-- SPARSE CONNECTIVITY -->
			<xsl:if test="not(number(SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count(.//SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number(.//@num_connections) div number($maxConnSize))>number(0.1)) ">
				<!---->	//sort the connections
<!---->			<!---->	std::sort(tempConns<xsl:value-of select="$varName"/>.begin(), tempConns<xsl:value-of select="$varName"/>.end(), sortConn);		
<!---->			<!---->	// now we have the sorted connections we can create the sparse array
<!---->			<!---->	//memset(C<xsl:value-of select="$varName"/>.gp, 0, sizeof(float)*tempConns<xsl:value-of select="$varName"/>.size());
<!---->			<!---->	memset(C<xsl:value-of select="$varName"/>.indInG, 0, sizeof(unsigned int)*<xsl:value-of select="$src_size"/>);
<!---->			<!---->	memset(C<xsl:value-of select="$varName"/>.ind, 0, sizeof(unsigned int)*tempConns<xsl:value-of select="$varName"/>.size());
<!---->			<!---->	{int currentSrcIndex = 0;
<!---->			<!---->	C<xsl:value-of select="$varName"/>.indInG[0] = 0; // always
<!---->			<!---->	for (int ind = 0; ind &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++ind) {
<!---->			<!---->		// we need to place the index of the first element in the list of dst indices
<!---->			<!---->		// associated with each src index in this array - so we put in indices until we 
<!---->			<!---->		// are on the current one, when we no longer are then we log that index and move on
<!---->			<!---->		while (currentSrcIndex &lt; tempConns<xsl:value-of select="$varName"/>[ind].src) {
<!---->			<!---->			C<xsl:value-of select="$varName"/>.indInG[currentSrcIndex+1] = ind;
<!---->			<!---->			++currentSrcIndex;
<!---->			<!---->		}
<!---->			<!---->		// now log the dst index
<!---->			<!---->		C<xsl:value-of select="$varName"/>.ind[ind] = tempConns<xsl:value-of select="$varName"/>[ind].dst;
<!---->			<!---->	}
<!---->			<!---->	// fill in the last running index
<!---->			<!---->	C<xsl:value-of select="$varName"/>.indInG[currentSrcIndex+1] = tempConns<xsl:value-of select="$varName"/>.size();
<!---->			<!---->	// fill in the remaining indices...
<!---->			<!---->	for (int ind = currentSrcIndex+2; ind &lt; <xsl:value-of select="$src_size"/>+1; ++ind) {
<!---->			<!---->		C<xsl:value-of select="$varName"/>.indInG[ind] = tempConns<xsl:value-of select="$varName"/>.size();
<!---->			<!---->	}
<!---->			<!---->	}
/*for (int i = 0; i &lt; <xsl:value-of select="$src_size"/>+1; ++i) {
cout &lt;&lt; <xsl:value-of select="$varName"/>.indInG[i] &lt;&lt; " IndSrc" &lt;&lt; endl;
}
for (int i = 0; i &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++i) {
cout &lt;&lt; <xsl:value-of select="$varName"/>.ind[i] &lt;&lt; " IndDst" &lt;&lt; endl;
}*/
			</xsl:if>
			<xsl:variable name="syn" select="."/>
			<!-- ################ PROPERTIES ########################-->
			<xsl:for-each select="SMLLOWNL:WeightUpdate/SMLNL:Property">
			<xsl:variable name="propName" select="@name"/>
			<xsl:variable name="synapse_array_name">
				<xsl:if test="document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeGradedSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeLearningSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeSynapse'">
					<xsl:value-of select="concat('gpSynapse',position())"/>_<xsl:value-of select="translate(../../../../SMLLOWNL:Neuron/@name,' -','SH')"/>_to_<xsl:value-of select="translate(../../../@dst_population,' -','SH')"/>
				</xsl:if>
				<xsl:if test="not(document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeGradedSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeLearningSynapse' or document(../@url)//SMLCL:ComponentClass/@name='GeNNNativeSynapse')">
					<xsl:value-of select="concat(@name ,'_WU',$varName)"/>
				</xsl:if>
			</xsl:variable>
			<!-- zero memory -->
			<!-- if DENSE -->
			<xsl:if test="number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count(.//SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number(.//@num_connections) div number($maxConnSize))>number(0.1) ">			
				<!---->	memset(<xsl:value-of select="$synapse_array_name"/>,<!---->
				<!---->0,<!---->
				<xsl:value-of select="concat('sizeof(float)*',$src_size,'*',$dst_size)"/>);
<!---->		</xsl:if>
				<xsl:if test="SMLNL:ValueList">
					<xsl:if test="$syn/SMLNL:FixedProbabilityConnection">
						<xsl:message terminate="yes">
Error: ValueList and FixedProbabilityConnection is a problem - so we don't support it
						</xsl:message>
					</xsl:if>
<!---->				<!---->	// Extract the data from whereever first of all
<!---->				<!---->	{vector &lt; prop &gt; tempProp; prop newProp;					
<!---->				<!-- IF ENCAPSULATED -->
					<xsl:if test="count(SMLNL:ValueList/SMLNL:Value)>0">
						<xsl:for-each select=".//SMLNL:Value">
<!---->				<!---->	newProp.ind = <xsl:value-of select="@index"/>; newProp.val = <xsl:value-of select="@value"/>; 
<!---->				<!---->	tempProp.push_back(newProp);	
<!---->					</xsl:for-each>
<!---->				</xsl:if>
					<!-- IF BINARY DATA -->
					<xsl:if test="SMLNL:ValueList/SMLNL:BinaryFile">
// file_name num_elements
<!---->				<!---->	FILE * data = fopen("<xsl:value-of select="SMLNL:ValueList/SMLNL:BinaryFile/@file_name"/>","rb");		
<!---->				<!---->	if (!data) {cerr &lt;&lt; "Error: could not open Property binary file"; exit(-1);}	
<!---->				<!---->	tempProp.resize(<xsl:value-of select="SMLNL:ValueList/SMLNL:BinaryFile/@num_elements"/>);
<!---->				<!---->	fread(&amp;(tempProp[0]), sizeof(prop), <xsl:value-of select="SMLNL:ValueList/SMLNL:BinaryFile/@num_elements"/>, data);			
<!---->				</xsl:if>
<!---->				<!----> // sort data
<!---->				<!----> std::sort(tempProp.begin(),tempProp.end(),sortProp);
<!---->				<!-- if DENSE -->
					<xsl:if test="number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1) ">
						<!-- loop connections and fill in memory array -->
						<!---->	for (int i = 0; i &lt; connections.size(); ++i) {
<!---->					<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[connections[i].dst*<xsl:value-of select="$src_size"/>+connections[i].src] = <!---->
						1;			
<!---->					<!---->	}
<!---->				</xsl:if>
					<!-- if SPARSE -->
					<xsl:if test="not(number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1)) ">
						<!-- loop connections and fill in memory array -->
						<!---->	for (int i = 0; i &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++i) {
<!---->					<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = tempProp[i].val;
<!---->					<!---->	}
<!---->				</xsl:if>
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:UniformDistribution">
<!---->				<!---->	// seed the RNG	
<!---->				<!---->	rngData.seed = <xsl:value-of select=".//@seed"/>;	
					<!-- loop connections and fill in memory array -->
<!---->					<!---->	for (int i = 0; i &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++i) {
<!---->					<!-- if DENSE -->
					<xsl:if test="number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[connections[i].dst*<xsl:value-of select="$src_size"/>+connections[i].src] = <!---->
					<!---->uniformRand(<xsl:value-of select="SMLNL:UniformDistribution/@minimum"/>,<xsl:value-of select="SMLNL:UniformDistribution/@maximum"/>);			
<!---->				</xsl:if>
					<!-- if SPARSE -->
					<xsl:if test="not(number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1)) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <!---->
					<!---->uniformRand(<xsl:value-of select="SMLNL:UniformDistribution/@minimum"/>,<xsl:value-of select="SMLNL:UniformDistribution/@maximum"/>);
cout &lt;&lt; <xsl:value-of select="$synapse_array_name"/>[i] &lt;&lt; endl;			
<!---->				</xsl:if>
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:NormalDistribution">
<!---->				<!---->	// seed the RNG	
<!---->				<!---->	rngData.seed = <xsl:value-of select=".//@seed"/>;			
<!---->				<!-- loop connections and fill in memory array -->
					<!---->	for (int i = 0; i &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++i) {
<!---->				<!-- if DENSE -->
					<xsl:if test="number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[connections[i].dst*<xsl:value-of select="$src_size"/>+connections[i].src] = <!---->
					<!---->normalRand(<xsl:value-of select="SMLNL:NormalDistribution/@mean"/>,<xsl:value-of select="SMLNL:NormalDistribution/@variance"/>);			
<!---->				</xsl:if>
					<!-- if SPARSE -->
					<xsl:if test="not(number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1)) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <!---->
					<!---->normalRand(<xsl:value-of select="SMLNL:NormalDistribution/@mean"/>,<xsl:value-of select="SMLNL:NormalDistribution/@variance"/>);			
<!---->				</xsl:if>		
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:PoissonDistribution">
<!---->				<!---->	// seed the RNG	
<!---->				<!---->	rngData.seed = <xsl:value-of select=".//@seed"/>;
<!---->					<!-- loop connections and fill in memory array -->
					<!---->	for (int i = 0; i &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++i) {
<!---->					<!-- if DENSE -->
					<xsl:if test="number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[connections[i].dst*<xsl:value-of select="$src_size"/>+connections[i].src] = <!---->
					<!---->poissonRand();			
<!---->				</xsl:if>
					<!-- if SPARSE -->
					<xsl:if test="not(number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1)) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <!---->
					<!---->poissonRand();		
<!---->				</xsl:if>		
<!---->				<!---->	}
<!---->			</xsl:if>
				<xsl:if test="SMLNL:FixedValue and document(../@url)//SMLCL:StateVariable[@name=$propName]">
					<!-- loop connections and fill in memory array -->
					<!---->	for (int i = 0; i &lt; tempConns<xsl:value-of select="$varName"/>.size(); ++i) {
<!---->					<!-- if DENSE -->
					<xsl:if test="number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1) ">			
<!---->					<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[connections[i].dst*<xsl:value-of select="$src_size"/>+connections[i].src] = <xsl:value-of select="SMLNL:FixedValue/@value"/>;	 <!---->
<!---->					</xsl:if>
					<!-- if SPARSE -->
					<xsl:if test="not(number($syn/SMLNL:FixedProbabilityConnection/@probability)>number(0.1) or (count($syn///SMLNL:Connection) div number($maxConnSize))>number(0.1) or (number($syn///@num_connections) div number($maxConnSize))>number(0.1)) ">			
<!---->				<!----><xsl:text>		</xsl:text><xsl:value-of select="$synapse_array_name"/>[i] = <xsl:value-of select="SMLNL:FixedValue/@value"/>;
<!---->				</xsl:if>		
<!---->				<!---->	}
<!---->			</xsl:if>	
			</xsl:for-each>		
		</xsl:when>
		<xsl:otherwise>
			<xsl:message terminate="yes">
Error: Unrecognised connection type
			</xsl:message>
		</xsl:otherwise>
	</xsl:choose>
</xsl:for-each>

initializeAllSparseArrays();


// ALLOCATE MEMORY FOR POISSON
	
	<!-- HACK FOR NOW -->
	<xsl:for-each select="//SMLLOWNL:Neuron[@url='GeNNNativePoisson.xml']"> <!-- FOR EACH POISSON SOURCE -->
		<!-- Fill an array size num_neurons with the rate value -->
		// add data to array
		<xsl:choose>
		<xsl:when test="./SMLNL:Property[@name='therate']/SMLNL:FixedValue">
		unsigned int rates<xsl:value-of select="translate(@name,' -','SH')"/>[<xsl:value-of select="@size"/>];<!---->
		for (unsigned int i = 0; i &lt; <xsl:value-of select="@size"/>; ++i)<!---->
			rates<xsl:value-of select="translate(@name,' -','SH')"/>[i] = <xsl:value-of select="./SMLNL:Property[@name='therate']/SMLNL:FixedValue/@value"/>;<!---->
		</xsl:when>
		<xsl:when test="./SMLNL:Property[@name='therate']/SMLNL:UniformDistribution">
		unsigned int rates<xsl:value-of select="translate(@name,' -','SH')"/>[<xsl:value-of select="@size"/>];<!---->
		for (unsigned int i = 0; i &lt; <xsl:value-of select="@size"/>; ++i)<!---->
			rates<xsl:value-of select="translate(@name,' -','SH')"/>[i] = uniformRand(<xsl:value-of select="./SMLNL:Property[@name='therate']/SMLNL:UniformDistribution/@minimum"/>,<xsl:value-of select="./SMLNL:Property[@name='therate']/SMLNL:UniformDistribution/@maximum"/>);<!---->
		</xsl:when>
		<xsl:when test="./SMLNL:Property[@name='therate']/SMLNL:NormalDistribution">
		unsigned int rates<xsl:value-of select="translate(@name,' -','SH')"/>[<xsl:value-of select="@size"/>];<!---->
		for (unsigned int i = 0; i &lt; <xsl:value-of select="@size"/>; ++i)<!---->
			rates<xsl:value-of select="translate(@name,' -','SH')"/>[i] = normalRand(<xsl:value-of select="./SMLNL:Property[@name='therate']/SMLNL:NormalDistribution/@mean"/>,<xsl:value-of select="./SMLNL:Property[@name='therate']/SMLNL:NormalDistribution/@variance"/>);<!---->
		</xsl:when>
		<xsl:when test="./SMLNL:Property[@name='therate']/SMLNL:PoissonDistribution">
		unsigned int rates<xsl:value-of select="translate(@name,' -','SH')"/>[<xsl:value-of select="@size"/>];<!---->
		for (unsigned int i = 0; i &lt; <xsl:value-of select="@size"/>; ++i)<!---->
			rates<xsl:value-of select="translate(@name,' -','SH')"/>[i] = poissonRand();<!---->
		</xsl:when>
		<xsl:when test="./SMLNL:Property[@name='therate']/SMLNL:ValueList">
		unsigned int rates<xsl:value-of select="translate(@name,' -','SH')"/> [] = {<!---->
			<!-- PRETTY SURE THIS WILL WORK - BUT IT IS SLOW AND I DON'T LIKE IT (load then sort instead!) -->
			<xsl:for-each select="./SMLNL:Property[@name='therate']/SMLNL:ValueList/SML:Value">
				<xsl:variable name="index" select="position()-1"/>
				<xsl:for-each select="./SMLNL:Property[@name='therate']/SMLNL:ValueList/SML:Value">
					<xsl:if test="@index=$index">
						<xsl:value-of select="concat(@value,',')"/>
					</xsl:if>
				</xsl:for-each>				
			</xsl:for-each>}
<!---->	</xsl:when>	
		<xsl:otherwise>
			<xsl:message terminate="yes">
Error: Native Poisson parameter 'therate' not found or undefined 
			</xsl:message>
		</xsl:otherwise>
		</xsl:choose>	
      	fprintf(stderr, "# %d %d %d %d \n", rates<xsl:value-of select="translate(@name,' -','SH')"/>[0],rates<xsl:value-of select="translate(@name,' -','SH')"/>[1],rates<xsl:value-of select="translate(@name,' -','SH')"/>[2],rates<xsl:value-of select="translate(@name,' -','SH')"/>[3]);

		// copy to GPU
		int size = sizeof(unsigned int)*<xsl:value-of select="@size"/>;
		unsigned int * d_rates<xsl:value-of select="translate(@name,' -','SH')"/>;
		if (which == GPU) {
			CHECK_CUDA_ERRORS((cudaMalloc((void**) &amp;d_rates<xsl:value-of select="translate(@name,' -','SH')"/>, size)));
			CHECK_CUDA_ERRORS((cudaMemcpy(d_rates<xsl:value-of select="translate(@name,' -','SH')"/>, rates<xsl:value-of select="translate(@name,' -','SH')"/>, size, cudaMemcpyHostToDevice))); 
		}
	</xsl:for-each> <!-- END FOR EACH POISSON SOURCE -->

  
// INIT CODE
  //initGRaw();
  if (which == CPU) {
    //theRates= baserates;
  }
  if (which == GPU) {
    copyStateToDevice();
    //theRates= d_baserates;
  }

  fprintf(stderr, "# neuronal circuitry built, start computation ... \n\n");

  //------------------------------------------------------------------
  // output general parameters to output file and start the simulation

  fprintf(stderr, "# We are running with fixed time step %f \n", DT);
  fprintf(stderr, "# initial wait time execution ... \n");

 t= 0.0;
 unsigned int offset = 0;
 float output [10];
 void *devPtr;
 
 FILE * time_file = fopen("<xsl:value-of select="$model_dir"/>/time.txt","w");
 
 // Init for logs
 <xsl:for-each select="$experiment_file//SMLEX:LogOutput">
 	<!-- Create the variable for the log temp file name -->
 	<xsl:variable name="logName"><xsl:value-of select="translate(@target,' ','_')"/>_<xsl:value-of select="@port"/>_log</xsl:variable>
 	
 	FILE * <xsl:value-of select="$logName"/>FILE = fopen("<xsl:value-of select="$log_dir"/>/<xsl:value-of select="$logName"/>.bin","wb");
	if (!<xsl:value-of select="$logName"/>FILE) {
		cerr &lt;&lt; "Could not open file for logging: " &lt;&lt; "<xsl:value-of select="$log_dir"/>/<xsl:value-of select="$logName"/>.bin";
		exit(-1);
	}
 	<!-- Create the lookup for what to log --> 
 	<xsl:if test="@indices">
 	vector &lt; float &gt; <xsl:value-of select="$logName"/>TEMP;
 	vector &lt; int &gt; <xsl:value-of select="$logName"/>INDS;
 	{
 	// extract indices from the string
 	string tempStr = "<xsl:value-of select="@indices"/>";
 		string subStr;
 		for (unsigned int i=0; i &lt; tempStr.size(); ++i) {
 			// if we don't have a comma, add the number ot the substring, otherwise add the substring int 
 			// to the vector and clear the substring...
 			if (tempStr[i] != ',') {
 				subStr.push_back(tempStr[i]);
 			} else {
 				<xsl:value-of select="$logName"/>INDS.push_back(atoi(subStr.c_str()));
 				subStr.clear();
 			}
 		}
 		// save the last val
 		<xsl:value-of select="$logName"/>INDS.push_back(atoi(subStr.c_str()));
 	}
 	</xsl:if>
 </xsl:for-each>
 
 timer.startTimer();	
 for (int i= 0; i &lt; <xsl:value-of select="number($experiment_file//SMLEX:Simulation/@duration)*1000.0 div number($experiment_file//@dt)"/>; i++) {
      
    if (which == GPU) {
       stepTimeGPU(<!-- THIS IS A LITTLE HACKY AS IT USES THE FILE URL WHICH COULD CHANGE... BUT WE'LL REDO THIS FOR INPUTS ANYWAY... -->
       	<xsl:for-each select="//SMLLOWNL:Neuron[@url='GeNNNativePoisson.xml']">
       		<!---->d_rates<xsl:value-of select="translate(@name,' -','SH')"/>,offset,<!---->
       	</xsl:for-each>
       <!----> t);      
       
       // Logging...
       
       <xsl:for-each select="$experiment_file//SMLEX:LogOutput">
       <xsl:variable name="target" select="@target"/>
       
       <!-- Create the variable for the log temp file name -->
       <xsl:variable name="logName"><xsl:value-of select="translate(@target,' ','_')"/>_<xsl:value-of select="@port"/>_log</xsl:variable>
       
       <xsl:variable name="host_var_name">
       <xsl:value-of select="@port"/><!---->
       <xsl:if test="count($model_file//SMLLOWNL:Neuron[@name=$target])=1">_NB</xsl:if>
       <xsl:if test="count($model_file//SMLLOWNL:WeightUpdate[@name=$target])=1">_WU</xsl:if>
       <xsl:if test="count($model_file//SMLLOWNL:PostSynapse[@name=$target])=1">_PS</xsl:if>
       <xsl:value-of select="translate(@target,' -','SH')"/>
       </xsl:variable>
       
       <xsl:variable name="var_size">
    		<xsl:for-each select="$model_file//SMLLOWNL:Neuron[@name=$target]"><xsl:value-of select="@size"/></xsl:for-each>
       		<xsl:for-each select="$model_file//SMLLOWNL:WeightUpdate[@name=$target]">1</xsl:for-each>
       		<xsl:for-each select="$model_file//SMLLOWNL:PostSynapse[@name=$target]"><xsl:variable name="dst" select="../../@dst_population"/><xsl:value-of select="//SMLLOWNL:Neuron[@name=$dst]/@size"/></xsl:for-each>       
       </xsl:variable>
       
       // Fetch variable from the device to the local array
       CHECK_CUDA_ERRORS(cudaMemcpy(<xsl:value-of select="$host_var_name"/>, d_<!---->
       <xsl:value-of select="@port"/><!---->
       <xsl:if test="count($model_file//SMLLOWNL:Neuron[@name=$target])=1">_NB</xsl:if>
       <xsl:if test="count($model_file//SMLLOWNL:WeightUpdate[@name=$target])=1">_WU</xsl:if>
       <xsl:if test="count($model_file//SMLLOWNL:PostSynapse[@name=$target])=1">_PS</xsl:if>
       <xsl:value-of select="translate(@target,' -','SH')"/>, <xsl:value-of select="$var_size"/>*sizeof(float), cudaMemcpyDeviceToHost));
        <xsl:if test="@indices">
		// Collate the selected values into the temporary variable
       <xsl:value-of select="$logName"/>TEMP.clear();
		for (unsigned int ind = 0; ind &lt; <xsl:value-of select="$logName"/>INDS.size(); ++ind) {
			// place each index into the temp array
			<xsl:value-of select="$logName"/>TEMP.push_back(<xsl:value-of select="$host_var_name"/>[<xsl:value-of select="$logName"/>INDS[ind]]);
		}
		// write to disk
		fwrite(&amp;(<xsl:value-of select="$logName"/>TEMP[0]), sizeof(float),<xsl:value-of select="$logName"/>TEMP.size(),<xsl:value-of select="$logName"/>FILE);
 		</xsl:if>
 		<xsl:if test="not(@indices)">
 		// write all to disk
		fwrite(<xsl:value-of select="$host_var_name"/>, sizeof(float),<xsl:value-of select="$var_size"/>,<xsl:value-of select="$logName"/>FILE);			
 		</xsl:if>
       
       </xsl:for-each>

      	// write out time to the GUI and check for the stop command
      	if (time_file) {
			// rewind the file and print the time
			fseek(time_file,0,SEEK_SET);
			fprintf(time_file, "%f", t);
		}
		
		FILE * stop_file = fopen("<xsl:value-of select="$model_dir"/>/stop.txt","r");
 		if (stop_file) break;
      	
      	//
	}
    if (which == CPU) {
       stepTimeCPU(<!-- THIS IS A LITTLE HACKY AS IT USES THE FILE URL WHICH COULD CHANGE... BUT WE'LL REDO THIS FOR INPUTS ANYWAY... -->
       	<xsl:for-each select="//SMLLOWNL:Neuron[@url='GeNNNativePoisson.xml']">
       		<!---->rates<xsl:value-of select="translate(@name,' -','SH')"/>,offset,<!---->
       	</xsl:for-each>
       	<!----> t);
	}
    t+= DT;
    //fprintf(stderr, "# one time step complete ... \n\n");
    
    
  }
  timer.stopTimer();
  fprintf(stderr, "Time taken = %f \n", timer.getElapsedTime());
  
  
  /// WRITE LOG XML
  
  <xsl:for-each select="$experiment_file//SMLEX:LogOutput">
  	<xsl:variable name="target" select="@target"/>
	<!-- WRITE XML FOR LOGS -->
	{
	<xsl:variable name="logName"><xsl:value-of select="translate(@target,' ','_')"/>_<xsl:value-of select="@port"/>_log</xsl:variable>
	FILE * <xsl:value-of select="@port"/>LOGREPORT;
	string logFileName = "<xsl:value-of select="$log_dir"/>/";
	logFileName.append("<xsl:value-of select="$logName"/>rep.xml");
	<xsl:value-of select="@port"/>LOGREPORT = fopen(logFileName.c_str(),"w");
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "&lt;LogReport&gt;\n");
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "	&lt;AnalogLog&gt;\n");
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "		&lt;LogFile&gt;<xsl:value-of select="$logName"/>.bin&lt;/LogFile&gt;\n");
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "		&lt;LogFileType&gt;binary&lt;/LogFileType&gt;\n");
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "		&lt;LogEndTime&gt;%f&lt;/LogEndTime&gt;\n",t);
	<xsl:if test="@indices">
		for (unsigned int i = 0; i &lt; <xsl:value-of select="$logName"/>INDS.size(); ++i) {
			fprintf(<xsl:value-of select="@port"/>LOGREPORT, "		&lt;LogCol index=\"%d\" heading=\"<xsl:value-of select="@port"/>\" dims=\"<!---->
			<!---->\" type=\"float\"/&gt;\n",<xsl:value-of select="$logName"/>INDS[i]);
		}
	</xsl:if>
	<xsl:if test="not(@indices)">
	   <xsl:variable name="var_size">
		<xsl:for-each select="$model_file//SMLLOWNL:Neuron[@name=$target]"><xsl:value-of select="@size"/></xsl:for-each>
		<xsl:for-each select="$model_file//SMLLOWNL:WeightUpdate[@name=$target]">1</xsl:for-each>
		<xsl:for-each select="$model_file//SMLLOWNL:PostSynapse[@name=$target]"><xsl:variable name="dst" select="../../@dst_population"/><xsl:value-of select="//SMLLOWNL:Neuron[@name=$dst]/@size"/></xsl:for-each>       
   	   </xsl:variable>
		fprintf(<xsl:value-of select="@port"/>LOGREPORT, "		&lt;LogAll size=\"%d\" headings=\"<xsl:value-of select="@name"/>\" type=\"float\" dims=\"<!---->
		<!---->\"/&gt;\n",<xsl:value-of select="$var_size"/>);	
	</xsl:if>
	fprintf(<xsl:value-of select="@port"/>LOGREPORT,"		&lt;TimeStep dt=\"%f\"/&gt;\n", DT);
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "	&lt;/AnalogLog&gt;\n");
	fprintf(<xsl:value-of select="@port"/>LOGREPORT, "&lt;/LogReport&gt;\n");

	fclose(<xsl:value-of select="@port"/>LOGREPORT);
	}
   </xsl:for-each>

  return 0;
}

</xsl:for-each> <!-- LEAVE NETWORK FILE-->

</xsl:template>

</xsl:stylesheet>
